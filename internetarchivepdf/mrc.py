# Author: Merlijn Boris Wolf Wajer <merlijn@archive.org>

from os import close, remove

from glob import glob
from tempfile import mkstemp
import subprocess

from PIL import Image
from skimage.filters import threshold_local, threshold_otsu
import numpy as np

import fitz

fitz.TOOLS.set_icc(True) # For good measure, not required


"""
TODO:

1. Port the Tesseract text writing to Python (from C++), so that I can easily
   repurpose it. The Tesseract C++ code requires information in the TessBaseAPI
   class (a memory instance of Tesseract result, and we have hOCR), so I could also
   look reading hOCR into the TessBaseAPI class, but that seems like a hack, so I'd
   rather port it to Python and have the code reading hOCR.

2. Read the images from the _imgonly.pdf (a PDF that is generated by petabox
   code). This is trivial, and already done in other code I've written. (This will
   ensure that the PDF recoding module doesn't have to know about different image
   stack formats and such.)

3. Keep DPI in mind (will come for free with above step); make the Tesseract
   text writing work on a smaller resolution (should again be no problem)

4. Integrate JBIG2 code from mupdf when the authors commit a fix to master.

5. Improve the MRC algorithm, by improving the foreground detection (either
   using ocropus binarisation or using a paper that both Hank and a friend of mine
   found: https://engineering.purdue.edu/~bouman/software/Text-Seg/tip30.pdf),
   improve background compression using JPEG2000 ROI
   (http://summit.sfu.ca/system/files/iritems1/2784/b36288305.pdf)

6. Figure out how to make the last pieces PDF/A compliant. I think I just need
   to add colourspaces to the JPX images that I am writing, write some metadata,
   and add ID tags to the trailer.
"""


KDU_COMPRESS = 'kdu_compress'
KDU_EXPAND = 'kdu_expand'
#KDU_COMPRESS = '/home/merlijn/archive/microfilm-issue-generator/bin/kdu_compress'
#KDU_EXPAND = '/home/merlijn/archive/microfilm-issue-generator/bin/kdu_expand'


def threshold_image(pil_image, rev=False, otsu=False):
    """
    Apply adaptive (local) thresholding, filtering out background noise to make
    the text more readable. Tesseract uses Otsu thresholding, which in our
    testing hasn't worked all that well, so we perform better thresholding
    before passing the image to tesseract.

    Returns the thresholded PIL image
    """
    img = np.array(pil_image)

    if otsu:
        try:
            binary_otsu = threshold_otsu(img)
        except ValueError:
            binary_otsu = np.ndarray(img.shape)
            binary_otsu[:] = 0

        if rev:
            binary_img = img > binary_otsu
        else:
            binary_img = img < binary_otsu
    else:
        block_size = 9
        #binary_local = threshold_local(img, block_size, method='gaussian')
        binary_local = threshold_local(img, block_size, offset=10, method='gaussian')
        if not rev:
            binary_img = img < binary_local
        else:
            binary_img = img > binary_local

    return binary_img


def threshold_image2(pil_image):
    local = threshold_image(pil_image)
    otsu = threshold_image(pil_image, otsu=True)

    return local & otsu

#def inverse_mask(mask):
#    inverse_mask = np.copy(mask)
#    inverse_mas[mask == True] = False
#    inverse_mas[mask == False] = True
#

def create_mrc_components(image):
    img = image
    if image.mode != 'L':
        img = image.convert('L')
    mask = threshold_image(img)
    #imask = inverse_mask(mask)

    mask_img = Image.fromarray(mask)

    np_im = np.array(image)

    np_bg = np.copy(np_im)
    np_fg = np.copy(np_im)

    # XXX: We likely don't want this to be the 'average'. We might want it (and
    # some neighbouring pixels!) to be 'background' colour, or something like
    # that.
    np_bg[mask] = np.average(np_im)

    # We might not want to touch these pixels, but let's set them to zero for
    # now for good measure.
    # np_fg[mask] = 0

    return mask, np_bg, np_fg


def create_mrc_hocr_components(image, hocr_word_data):
    img = image
    if image.mode != 'L':
        img = image.convert('L')

    image_mask = Image.new('1', image.size)
    image_cont = Image.new(image.mode, image.size)

    OTSU = False

    if OTSU:
        otsu_mask = Image.new('1', image.size)

    for paragraphs in hocr_word_data:
        for lines in paragraphs['lines']:
            for word in lines['words']:
                if not word['text'].strip():
                    continue

                wordimg = img.crop(word['bbox'])
                wordimg_th = Image.fromarray(threshold_image2(wordimg)).convert('1')

                if OTSU:
                    wordimg_o = img.crop(word['bbox'])
                    wordimg_th_o = Image.fromarray(threshold_image(wordimg_o, otsu=True)).convert('1')

                # Make sure we're not greyscale
                wordimg = image.crop(word['bbox'])

                # TODO: Over elkaar heen pasten is een probleem (!!!) -
                # mergen bij pasten?
                intbox = [int(x) for x in word['bbox']]

                # TODO: XXX: Let's make sure we do this with numpy arrays, and
                # only copy the pixels that are in the wordimg_th (mask). That
                # way there is no way we can paste over existing bounding boxes
                # (I have seen this happen already!)

                # TODO: Let's work on numpy arrays.
                # And then only copy over pixels that are part of the threshold.
                image_mask.paste(wordimg_th, intbox)

                if OTSU:
                    otsu_mask.paste(wordimg_th_o, intbox)

                image_cont.paste(wordimg, intbox)
                #image_cont.paste(wordimg_con, intbox)

    # TODO: Massage image?

    mask_arr = np.array(image_mask)
    mask_inv = mask_arr ^ np.ones(mask_arr.shape, dtype=bool)

    if OTSU:
        otsu_arr = np.array(otsu_mask)
        otsu_inv = otsu_arr ^ np.ones(otsu_arr.shape, dtype=bool)


    if OTSU:
        image_arr = np.array(image)
        image_arr[otsu_arr] = np.mean(image_arr)

        image = Image.fromarray(image_arr)

    #w, h = image.size
    #image.thumbnail((w/2, h/2))
    image_arr = np.array(image)

    # Fill non relevant of foreground with black pixels for now.
    # This is not ideal / perfect, but it should save some when encoding, and
    # should work OK with black text.
    foreground_arr = np.array(image_cont)
    if image.mode == 'RGB' or image.mode == 'RGBA':
        foreground_arr[mask_inv] = (0, 0, 0)
    else:
        foreground_arr[mask_inv] = 0
    #foreground_arr[mask_arr] = 0

    return mask_arr, image_arr, foreground_arr


def encode_mrc_images(mask, np_bg, np_fg, bg_slope=0.1, fg_slope=0.05,
                      tmp_dir=None, jbig2=True):
    # Create mask
    #fd, mask_img_png = mkstemp(prefix='mask', suffix='.pgm')
    fd, mask_img_png = mkstemp(prefix='mask', suffix='.png', dir=tmp_dir)
    close(fd)
    if jbig2:
        fd, mask_img_jbig2 = mkstemp(prefix='mask', suffix='.jbig2', dir=tmp_dir)
        close(fd)

    img = Image.fromarray(mask)
    img.save(mask_img_png, compress_level=0) # XXX: Check compress_level vs compress

    if jbig2:
        out = subprocess.check_output(['jbig2', mask_img_png])
        #out = subprocess.check_output(['jbig2', '--pdf', mask_img_png])
        fp= open(mask_img_jbig2, 'wb+')
        fp.write(out)
        fp.close()

    # Create background
    fd, bg_img_tiff = mkstemp(prefix='bg', suffix='.tiff', dir=tmp_dir)
    close(fd)
    fd, bg_img_jp2 = mkstemp(prefix='bg', suffix='.jp2', dir=tmp_dir)
    close(fd)
    remove(bg_img_jp2) # XXX: Kakadu doesn't want the file to exist, so what are
                       # we even doing

    bg_img = Image.fromarray(np_bg)
    bg_img.save(bg_img_tiff)

    subprocess.check_call([KDU_COMPRESS,
        '-i', bg_img_tiff, '-o', bg_img_jp2,
        '-slope', str(bg_slope),
        'Clayers=20', 'Creversible=yes', 'Rweight=220', 'Rlevels=5',
        ], stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
    remove(bg_img_tiff)

    # Create foreground
    fd, fg_img_tiff = mkstemp(prefix='fg', suffix='.tiff', dir=tmp_dir)
    close(fd)
    fd, fg_img_jp2 = mkstemp(prefix='fg', suffix='.jp2', dir=tmp_dir)
    close(fd)
    remove(fg_img_jp2) # XXX: Kakadu doesn't want the file to exist, so what are
                       # we even doing

    fg_img = Image.fromarray(np_fg)
    fg_img.save(fg_img_tiff)

    subprocess.check_call(['convert', mask_img_png, mask_img_png + '.pgm'])
    subprocess.check_call([KDU_COMPRESS,
        '-i', fg_img_tiff, '-o', fg_img_jp2,
        '-slope', str(fg_slope),
        'Clayers=20', 'Creversible=yes', 'Rweight=220', 'Rlevels=5',
         '-roi', mask_img_png + '.pgm,0.5',
        ], stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
    remove(mask_img_png + '.pgm')
    remove(fg_img_tiff)

    if jbig2:
        remove(mask_img_png)


    # XXX: Return PNG (which mupdf will turn into ccitt) until mupdf fixes their
    # JBIG2 support
    #print(mask_img_png, bg_img_jp2, fg_img_jp2)
    #print(mask_img_jbig2, bg_img_jp2, fg_img_jp2)
    if jbig2:
        return mask_img_jbig2, bg_img_jp2, fg_img_jp2
    else:
        return mask_img_png, bg_img_jp2, fg_img_jp2


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(
            description='PDF recoder using MRC and '\
                        'hOCR for text file placement')
    parser.add_argument('--jp2-stack', help='Base path of unpacked JP2 stack',
                        default=None)
    parser.add_argument('--tesseract-text-only-pdf', help='Path to tesseract'\
                        'text-only PDF (PDF with just invisible text)',
                        default=None)
    parser.add_argument('--out-pdf', help='File to write to', default=None)

    args = parser.parse_args()

    inpath = args.jp2_stack
    tesspath = args.tesseract_text_only_pdf
    outpath = args.out_pdf

    pdf = fitz.open(tesspath)

    i = 0
    for f in sorted(glob(inpath + '*.jp2')):
        # XXX: Make this /tmp/in.tiff) a tempfile
        subprocess.check_call([KDU_EXPAND, '-i', f, '-o', '/tmp/in.tiff'],
                              stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        mask, bg, fg = create_mrc_components(Image.open('/tmp/in.tiff'))
        mask_f, bg_f, fg_f = encode_mrc_images(mask, bg, fg)

        #page = pdf.newPage(-1)
        page = pdf[i]

        bg_contents = open(bg_f, 'rb').read()
        page.insertImage(page.rect, stream=bg_contents, mask=None)

        fg_contents = open(fg_f, 'rb').read()
        mask_contents = open(mask_f, 'rb').read()

        page.insertImage(page.rect, stream=fg_contents, mask=mask_contents)

        remove(mask_f)
        remove(bg_f)
        remove(fg_f)

        i += 1
        if i % 10 == 0:
            print('Saving')
            pdf.save(outpath)

    print(fitz.TOOLS.mupdf_warnings())
    pdf.save(outpath, deflate=True)
